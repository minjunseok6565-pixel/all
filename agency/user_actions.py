from __future__ import annotations

"""User-initiated (proactive) interactions for the agency system.

This module is *pure business logic* (no DB I/O). It mirrors the design of
agency/responses.py but is used when the user initiates an action without a
player-generated event.

Examples:
- MEET_PLAYER: private talk to calm an issue before it becomes an event.
- PRAISE / WARN: relationship management.
- SET_EXPECTATION: proactively set a promise (e.g., ROLE/LOAD/HELP/EXTENSION_TALKS).
- START_EXTENSION_TALKS: record that talks actually started (SSOT: agency_events).

The DB layer (agency/interaction_service.py) is responsible for:
- validating roster/team ownership
- persisting agency_events and player_agency_state
- persisting promises when created
"""

from dataclasses import dataclass, field
from typing import Any, Dict, List, Literal, Mapping, Optional, Tuple

from .config import AgencyConfig, DEFAULT_CONFIG
from .promises import PromiseSpec, PromiseType, due_month_from_now
from .utils import clamp, clamp01, mental_norm, norm_date_iso, safe_float


UserActionType = Literal[
    "MEET_PLAYER",
    "PRAISE",
    "WARN",
    "SET_EXPECTATION",
    "START_EXTENSION_TALKS",
]


@dataclass(frozen=True, slots=True)
class UserActionOutcome:
    ok: bool
    action_type: str

    # Event written to agency_events.
    event_type: str
    severity: float = 0.0

    # State updates to write (absolute values; DB layer clamps).
    state_updates: Dict[str, Any] = field(default_factory=dict)

    # Optional promise to persist.
    promise: Optional[PromiseSpec] = None

    # Explainability
    reasons: List[Dict[str, Any]] = field(default_factory=list)
    meta: Dict[str, Any] = field(default_factory=dict)


def apply_user_action(
    *,
    action_type: str,
    state: Mapping[str, Any],
    mental: Mapping[str, Any],
    action_payload: Optional[Mapping[str, Any]] = None,
    now_date_iso: Optional[str] = None,
    cfg: AgencyConfig = DEFAULT_CONFIG,
) -> UserActionOutcome:
    """Apply a user-initiated action (pure logic)."""

    at = str(action_type or "").upper()
    payload = dict(action_payload or {})

    if now_date_iso is None:
        now_date_iso = str(payload.get("now_date") or "")
    now_d = norm_date_iso(now_date_iso) or "2000-01-01"

    if at not in {"MEET_PLAYER", "PRAISE", "WARN", "SET_EXPECTATION", "START_EXTENSION_TALKS"}:
        return UserActionOutcome(
            ok=False,
            action_type=at,
            event_type="USER_ACTION",
            reasons=[{"code": "USER_ACTION_UNKNOWN", "evidence": {"action_type": at}}],
        )

    trust0 = clamp01(state.get("trust", 0.5))
    mfr0 = clamp01(state.get("minutes_frustration", 0.0))
    tfr0 = clamp01(state.get("team_frustration", 0.0))
    rfr0 = clamp01(state.get("role_frustration", 0.0))
    cfr0 = clamp01(state.get("contract_frustration", 0.0))
    hfr0 = clamp01(state.get("health_frustration", 0.0))
    chfr0 = clamp01(state.get("chemistry_frustration", 0.0))

    lev = float(clamp01(safe_float(state.get("leverage"), 0.0)))

    ego = mental_norm(mental, "ego")
    loy = mental_norm(mental, "loyalty")
    coach = mental_norm(mental, "coachability")
    adapt = mental_norm(mental, "adaptability")

    impact = 0.45 + 0.55 * lev
    pos_mult = clamp(0.85 + 0.35 * coach + 0.25 * loy + 0.10 * adapt - 0.15 * ego, 0.55, 1.65)
    neg_mult = clamp(0.90 + 0.50 * ego - 0.25 * loy - 0.10 * coach, 0.55, 2.10)

    trust1 = trust0
    mfr1, tfr1, rfr1, cfr1, hfr1, chfr1 = mfr0, tfr0, rfr0, cfr0, hfr0, chfr0

    promise: Optional[PromiseSpec] = None
    reasons: List[Dict[str, Any]] = []

    # ------------------------------------------------------------------
    # Action behaviors
    # ------------------------------------------------------------------

    if at == "MEET_PLAYER":
        dt = float(getattr(cfg.responses, "trust_acknowledge", 0.03)) * impact * pos_mult
        trust1 += dt

        focus = str(payload.get("focus_axis") or "").upper()
        # If no focus was provided, calm the highest frustration axis.
        axis_vals: List[Tuple[str, float]] = [
            ("MINUTES", mfr0),
            ("TEAM", tfr0),
            ("ROLE", rfr0),
            ("CONTRACT", cfr0),
            ("HEALTH", hfr0),
            ("CHEMISTRY", chfr0),
        ]
        if focus not in {a for a, _ in axis_vals}:
            focus = max(axis_vals, key=lambda kv: kv[1])[0]

        calm = 0.03 * impact * pos_mult

        if focus == "MINUTES":
            mfr1 -= calm
        elif focus == "TEAM":
            tfr1 -= calm
        elif focus == "ROLE":
            rfr1 -= calm
        elif focus == "CONTRACT":
            cfr1 -= calm
        elif focus == "HEALTH":
            hfr1 -= calm
        elif focus == "CHEMISTRY":
            chfr1 -= calm

        reasons.append({"code": "USER_MEET_PLAYER", "evidence": {"trust_delta": dt, "focus_axis": focus, "calm": calm}})

    elif at == "PRAISE":
        dt = 0.02 * impact * pos_mult
        trust1 += dt
        chfr1 -= 0.01 * impact * pos_mult
        reasons.append({"code": "USER_PRAISE", "evidence": {"trust_delta": dt}})

    elif at == "WARN":
        dt = -0.02 * impact * neg_mult
        trust1 += dt
        reasons.append({"code": "USER_WARN", "evidence": {"trust_delta": dt}})

    elif at == "SET_EXPECTATION":
        # Create a promise without a triggering player event.
        ptype = str(payload.get("promise_type") or "").upper()
        if ptype not in {"MINUTES", "ROLE", "HELP", "LOAD", "EXTENSION_TALKS"}:
            return UserActionOutcome(
                ok=False,
                action_type=at,
                event_type="USER_ACTION",
                reasons=[{"code": "USER_EXPECTATION_BAD_PROMISE_TYPE", "evidence": {"promise_type": ptype}}],
            )

        # Default due windows (can be tuned later via config).
        due_months = 1
        if ptype == "HELP":
            due_months = 2

        due = due_month_from_now(now_d, int(payload.get("due_months") or due_months))

        target_value = payload.get("target_value")
        tv = safe_float(target_value, None)
        if tv is None:
            tv = None

        target: Dict[str, Any] = dict(payload.get("target") or {}) if isinstance(payload.get("target"), Mapping) else {}
        # Common convenience keys
        if ptype == "ROLE" and "role" not in target:
            tr = str(payload.get("target_role") or payload.get("role") or "STARTER").upper()
            target["role"] = tr
        if ptype == "LOAD" and (tv is None) and "max_mpg" in payload:
            tv = safe_float(payload.get("max_mpg"), None)

        promise = PromiseSpec(
            promise_type=ptype,  # type: ignore[arg-type]
            due_month=due,
            target_value=tv,
            target=target,
        )

        trust1 += 0.01 * impact * pos_mult
        reasons.append({"code": "USER_SET_EXPECTATION", "evidence": {"promise_type": ptype, "due_month": due}})

    elif at == "START_EXTENSION_TALKS":
        # No promise created; this event is used as SSOT evidence.
        dt = 0.02 * impact * pos_mult
        trust1 += dt
        reasons.append({"code": "USER_START_EXTENSION_TALKS", "evidence": {"trust_delta": dt}})

    trust1 = clamp01(trust1)
    mfr1 = clamp01(mfr1)
    tfr1 = clamp01(tfr1)
    rfr1 = clamp01(rfr1)
    cfr1 = clamp01(cfr1)
    hfr1 = clamp01(hfr1)
    chfr1 = clamp01(chfr1)

    # Build state updates (absolute values)
    updates: Dict[str, Any] = {
        "trust": float(trust1),
        "minutes_frustration": float(mfr1),
        "team_frustration": float(tfr1),
        "role_frustration": float(rfr1),
        "contract_frustration": float(cfr1),
        "health_frustration": float(hfr1),
        "chemistry_frustration": float(chfr1),
    }

    event_type = "USER_ACTION"
    sev = 0.10
    if at == "START_EXTENSION_TALKS":
        event_type = "CONTRACT_TALKS_STARTED"
        sev = 0.20

    meta = {
        "action_type": at,
        "now_date": now_d,
        "scales": {
            "leverage": float(lev),
            "impact": float(impact),
            "pos_mult": float(pos_mult),
            "neg_mult": float(neg_mult),
        },
        "before": {
            "trust": float(trust0),
            "minutes_frustration": float(mfr0),
            "team_frustration": float(tfr0),
            "role_frustration": float(rfr0),
            "contract_frustration": float(cfr0),
            "health_frustration": float(hfr0),
            "chemistry_frustration": float(chfr0),
        },
        "after": {
            "trust": float(trust1),
            "minutes_frustration": float(mfr1),
            "team_frustration": float(tfr1),
            "role_frustration": float(rfr1),
            "contract_frustration": float(cfr1),
            "health_frustration": float(hfr1),
            "chemistry_frustration": float(chfr1),
        },
    }

    return UserActionOutcome(
        ok=True,
        action_type=at,
        event_type=event_type,
        severity=float(clamp01(sev)),
        state_updates=updates,
        promise=promise,
        reasons=reasons,
        meta=meta,
    )
